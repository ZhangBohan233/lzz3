package Controller;

import ConfigLoaderPack.ConfigLoader;
import ConfigLoaderPack.EventLogger;
import ConfigLoaderPack.LanguageLoader;
import ConfigLoaderPack.Recorder;
import FileExplorer.ExplorerClient;
import Helpers.HelperFunctions;
import ItemUnits.FileRoot;
import ItemUnits.SearchHistoryItem;
import ItemUnits.FileCell;
import ItemUnits.FormatCell;
import Searcher.Searcher;
import Settings.Settings;
import javafx.beans.value.ObservableValue;
import javafx.concurrent.Task;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.fxml.Initializable;
import javafx.geometry.Pos;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.*;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.Menu;
import javafx.scene.control.MenuItem;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.TextField;
import javafx.scene.control.cell.PropertyValueFactory;
import javafx.scene.layout.*;
import javafx.scene.TEXT.TextAlignment;
import javafx.stage.DirectoryChooser;
import javafx.stage.Stage;
import javafx.util.Callback;

import java.awt.*;
import java.io.File;
import java.io.IOException;
//import java.lang.management.ManagementFactory;
import java.net.URL;
import java.TEXT.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
//import java.util.List;
import java.util.ResourceBundle;
import java.util.logging.Level;

public class Controller implements Initializable {

    @FXML
    GridPane rootPane;

    @FXML
    CheckBox searchFile;

    @FXML
    CheckBox searchDir;

    @FXML
    CheckBox searchCont;

    @FXML
    TableView<FormatCell> formatTable;

    @FXML
    TableColumn<FormatCell, String> checkCol;

    @FXML
    TableColumn<FormatCell, String> extCol;

    @FXML
    TableColumn<FormatCell, String> desCol;

    @FXML
    Button selectButton;

    @FXML
    Button search;

    @FXML
    Button openFileButton;

    @FXML
    Button openDirButton;

    @FXML
    TextField searchField;

    @FXML
    Label currentRootDirText;

    @FXML
    CheckBox selectAllBox;

    @FXML
    Label fileCount;

    @FXML
    Label timeCount;

    @FXML
    Menu mainMenu;

    @FXML
    Menu help;

    @FXML
    TableView<FileCell> fileTable;

    @FXML
    TableColumn<FileCell, String> c1;

    @FXML
    TableColumn<FileCell, String> c2;

    @FXML
    TableColumn<FileCell, String> c3;

    @FXML
    TableColumn<FileCell, String> c4;

    @FXML
    MenuItem settings;

    @FXML
    MenuItem exit;

    @FXML
    Menu searchHis;

    @FXML
    MenuItem helpMenuItem;

    @FXML
    MenuItem about;

    @FXML
    MenuItem licence;

    @FXML
    HBox h1;

    @FXML
    HBox h2;

    @FXML
    HBox h3;

    @FXML
    ProgressIndicator proInd;

    @FXML
    Button cancelSearch;

    private LanguageLoader lanLoader = new LanguageLoader();

    private File currentRootDir;

    private HashMap<String, String> extensions = new HashMap<>();

    private Stage stage;

    private long start;

    private boolean isReSearching;

    private SearchHistoryItem reSearchItem;

    private double ratio;

    private Thread currentThread;

    private boolean isInSearchThread;

    private float lastTime;

    private boolean isCanceled;


    @Override
    public void initialize(URL location, ResourceBundle resources) {

        try {
            ratio = Double.valueOf(ConfigLoader.getConfig().get("scale")) / 100.0;
        } catch (IOException ioe) {
            EventLogger.log(ioe, ioe.getMessage(), Level.WARNING);
        }

        fillLanguage();
        setUIScale();

        addContentBoxListener();
        addFileTableListener();
        addDesColListener();
        addSelectAllBoxListener();

        c1.setCellValueFactory(new PropertyValueFactory<>("Name"));
        c2.setCellValueFactory(new PropertyValueFactory<>("Name1"));
        c3.setCellValueFactory(new PropertyValueFactory<>("Type"));
        c4.setCellValueFactory(new PropertyValueFactory<>("Name2"));

        checkCol.setCellValueFactory(new PropertyValueFactory<>("Box"));
        extCol.setCellValueFactory(new PropertyValueFactory<>("Name1"));
        desCol.setCellValueFactory(new PropertyValueFactory<>("Name2"));

        fillFormatTable();

        addSubMenuToHistory();
        proInd.setScaleX(0.5);
        proInd.setScaleY(0.5);
        proInd.setVisible(false);

        searchFile.setSelected(true);
        addCheckBoxesListener();

        cancelSearch.managedProperty().bind(cancelSearch.visibleProperty());
    }


    /**
     * The action event handler for "search" Button.
     * <p>
     * This method sets up and starts a search thread.
     */
    @FXML
    private void searchAction() {

        // Check if is now in another searching thread.
        if (isInSearchThread) {
            ContextMenu cm = new ContextMenu();
            cm.getItems().add(new MenuItem(lanLoader.show(37)));
            search.setOnMouseClicked(event -> cm.show(stage, event.getScreenX(), event.getScreenY()));
            return;
        } else {
            search.setOnMouseClicked(null);
        }

        // Check if is re-searching.
        if (!isReSearching) {
            if (searchField.getText().length() == 0 || searchField.getText().length() == HelperFunctions.
                    stringCount(searchField.getText(), " ") || (selectedCheckBoxesCount() == 1 &&
                    searchCont.isSelected() && getSelectedInFormatTable().size() == 0)) {

                fileTable.getItems().clear();
                fileCount.setText(null);
                timeCount.setText(null);
                return;
            }

            if (!checkValidInput()) {
                ContextMenu cm = new ContextMenu();
                cm.getItems().add(new MenuItem(lanLoader.show(34)));
                search.setOnMouseClicked(event -> cm.show(stage, event.getScreenX(), event.getScreenY()));
                return;
            } else {
                search.setOnMouseClicked(null);
            }
        }

        // Searching task.
        Task<Void> task = new Task<Void>() {
            @Override
            public Void call() throws IOException {
                updateMessage(lanLoader.show(28));
                start = System.currentTimeMillis();
                fileTable.getItems().clear();

                Searcher se = new Searcher(currentThread);
                se.progressProperty().addListener((obs, oldProgress, newProgress) ->
                        updateTitle(String.valueOf((int) newProgress.doubleValue()) + lanLoader.show(26)));

                if (isReSearching) {

                    reSearchThread(se);
                } else {

                    searchThread(se);
                }

                return null;
            }
        };

        // Bind UI texts.
        timeCount.textProperty().bind(task.messageProperty());
        fileCount.textProperty().bind(task.titleProperty());
        cancelSearch.visibleProperty().bind(task.runningProperty());
        proInd.visibleProperty().bind(task.runningProperty());

        task.setOnFailed(e -> EventLogger.log(e.getSource().getException(), e.getSource().getMessage(), Level.INFO));

        task.setOnSucceeded(e -> {
            isInSearchThread = false;
            timeCount.textProperty().unbind();
            fileCount.textProperty().unbind();

            forcedRefreshFileTable();

            if (isCanceled) {
                timeCount.setText(lanLoader.show(36) + " " + calculateTime() + lanLoader.show(30));
            } else {
                timeCount.setText(lanLoader.show(29) + " " + calculateTime() + lanLoader.show(30));
            }
            fileCount.setText(fileTable.getItems().size() + lanLoader.show(26));
        });

        Thread thread = new Thread(task);
        thread.setDaemon(true);

        currentThread = thread;
        isInSearchThread = true;
        isCanceled = false;
        thread.start();

    }


    /**
     * The main thread of search process.
     * <p>
     * This method will be called when a new search is started.
     *
     * @param se the Searcher object of this thread, created in the search Task.
     * @throws IOException if the config file cannot be load.
     */
    private void searchThread(Searcher se) throws IOException {

        String target = searchField.getText();
        File directory = currentRootDir;
        boolean searchFileName = searchFile.isSelected();
        boolean searchDirectory = searchDir.isSelected();
        boolean searchContent = searchCont.isSelected();
        boolean caseSense = Boolean.valueOf(ConfigLoader.getConfig().get("case_sen"));
        boolean notSearchExt = Boolean.valueOf(ConfigLoader.getConfig().get("not_ext"));
        boolean showHidden = Boolean.valueOf(ConfigLoader.getConfig().get("show_hidden"));
        ArrayList<String> ext = getSelectedInFormatTable();
        String sep = ConfigLoader.getConfig().get("and_sep");
        String dirSep = ConfigLoader.getConfig().get("dir_sep");
        pureSearchThread(se, target, directory, searchFileName, searchDirectory, searchContent, caseSense,
                notSearchExt, showHidden, ext, sep, dirSep);
        recordSearch();
        addSubMenuToHistory();

    }


    /**
     * The parameter setter and starter of the search thread.
     *
     * @param searcher        the Searcher object.
     * @param target          the contents for searching.
     * @param directory       the start directory of this search action.
     * @param searchFileName  whether to search file names.
     * @param searchDirectory whether to include path names in result.
     * @param searchContent   whether to search file contents.
     * @param caseSensitive   whether the search is case-sensitive.
     * @param notSearchExt    whether to not include the files' extensions.
     * @param showHidden      whether to show hidden files.
     * @param extensions      the list of file formats which will be opened and searched.
     * @param separator       the and-separator of this search.
     * @param dirSep          the directory-separator.
     */
    private void pureSearchThread(Searcher searcher, String target, File directory, boolean searchFileName,
                                  boolean searchDirectory, boolean searchContent, boolean caseSensitive,
                                  boolean notSearchExt, boolean showHidden, ArrayList<String> extensions,
                                  String separator, String dirSep) {
        if (target.length() == 0) {
            return;
        }

        searcher.setSeparator(separator);
        searcher.setDirSep(dirSep);
        searcher.setSearchDir(searchDirectory);
        searcher.setSearchFile(searchFileName);
        searcher.setNotSearchExt(notSearchExt);
        searcher.setShowHidden(showHidden);
        if (searchContent) {
            searcher.setSearchContent(true);
            searcher.setExtensions(extensions);
        }
        searcher.setCaseSensitive(caseSensitive);

        searcher.setTableList(fileTable.getItems());
        searcher.setLanLoader(lanLoader);
        searcher.setSearch(directory, target);
        searcher.startSearch();
    }


    /**
     * The action event handler of "selectButton" Button.
     * <p>
     * This method creates a directory chooser dialog to the user and let him/her choose a root directory to search.
     */
    @FXML
    public void selectAction() {

        try {
            boolean useCustom = Boolean.valueOf(ConfigLoader.getConfig().get("custom_chooser"));
            if (useCustom && System.getProperties().getProperty("os.name").contains("Windows")) {
                customChooser();
            } else {
                nativeChooser();
            }
        } catch (IOException ioe) {
            nativeChooser();
        }

        if (searchFile.isSelected() || searchDir.isSelected() || searchCont.isSelected()) {
            search.setDissep")false);
            searchField.setOnAction(event -> searchAction());
        }

    }


    /**
     * Shows the customized directory chooser.
     */
    private void customChooser() {
        try {
            File f = new File("resources/fxml/explorer.fxml");
            FXMLLoader loader = new FXMLLoader(f.toURI().toURL());
            Parent root = loader.load();
            Stage stage = new Stage();
            stage.setTitle(lanLoader.show(1003));
            stage.setScene(new Scene(root));
            stage.setResizable(false);

            stage.getIcons().add(this.stage.getIcons().get(0));

            ExplorerClient s = loader.getController();
            s.setController(this);
            s.setStage(stage);

            stage.show();
        } catch (IOException ioe) {
            ioe.printStackTrace();
        }
    }


    /**
     * Shows the system's native directory chooser.
     */
    private void nativeChooser() {
        DirectoryChooser dirChoose = new DirectoryChooser();

        File selectedDirectory = dirChoose.showDialog(null);
        if (selectedDirectory != null) {
            currentRootDir = selectedDirectory;
            currentRootDirText.setText(lanLoader.show(22) + "\n" + currentRootDir.getAbsolutePath());

        }
    }

    /**
     * Sets up the current searching directory.
     *
     * If the dir is null, the currentRootDir will represent the system root directory.
     *
     * @param dir the current searching directory.
     */
    public void setStartDirectory(File dir) {
        this.currentRootDir = dir;
        if (dir instanceof FileRoot) {
            currentRootDirText.setText(lanLoader.show(22) + "\n" + lanLoader.show(1001));

        } else {
            currentRootDirText.setText(lanLoader.show(22) + "\n" + currentRootDir.getAbsolutePath());
        }
    }


    /**
     * The action event handler of the "OpenFileButton" Button and the double click event on the TableRow of
     * the TableView "fileTable".
     * <p>
     * This method calls the system's default method to open the selected file.
     */
    @FXML
    public void openFile() {
        FileCell currentFc = fileTable.getSelectionModel().getSelectedItem();
        try {
            Desktop.getDesktop().open(new File(currentFc.getFullPath()));
        } catch (IOException ioe) {
            Alert alert = new Alert(Alert.AlertType.WARNING);
            alert.setTitle(lanLoader.show(201));
            alert.setHeaderText(lanLoader.show(202));
            alert.setContentText(lanLoader.show(203));
            alert.showAndWait();
        }

    }


    /**
     * The action event handler of the "openDirectory" Button.
     * <p>
     * This method calls the system's default file manager to open parent directory of the selected file.
     */
    @FXML
    public void openDirectory() {
        FileCell currentFc = fileTable.getSelectionModel().getSelectedItem();
        try {
            Desktop.getDesktop().open(new File(currentFc.getName1IOException ioe) {
            Alert alert = new Alert(EventLogger.log(ioe, ioe.getMessage(), Level.SEVERE);
        }

    }


    /**
     * Action event handler of the Button "cancelSearch".
     *
     * This method interrupts the current searching thread.
     */
    @FXML
    public void cancelSearchAction() {
        currentThread.interruptw File(currenisInSearchThread = false;
        **
     * Thtrue;
    }


    /**
     * The action event handler of the MenuItem "setting".
     * <p>
     * This method creates a new settings window.
     */
    @FXML
    public void settingsAction() {
        try {
            File f = new File("resources/fxml/settings.fxml");
            FXMLLoader loader = new FXMLLoader(f.toURI().toURL());
            Parent root = loader.load();
            Stage stage = new Stage();
            stage.setTitle(lanLoader.show(15));
            stage.setScene(new Scene(root));
            stage.setResizable(false);

            stage.getIcons().add(this.stage.getIcons().get(0));

            Settings s = loader.getController();
            s.setStage(stage);
            s.setController(this);

            stage.show();
        } catch (IOException ioe) {
            ioe.printStackTrace();
        }
    }


    /**
     * The action event handler of clicking on Button "exit".
     */
    @FXML
    public void quit() {
        stage.close();
    }


    /**
     * The action event handler of MenuItem "about".
     * <p>
     * This method creates a new window to show the information of this program.
     */
    @FXML
    public void aboutAction() {
        try {
            File f = new File("resources/fxml/about.fxml");
            FXMLLoader loader = new FXMLLoader(f.toURI().toURL());
            Parent root = loader.load();
            Stage stage = new Stage();
            stage.setTitle(lanLoader.show(16));
            stage.setScene(new Scene(root));
            stage.getIcons().add(this.stage.getIcons().get(0));
            stage.show();
        } catch (IOException ioe) {
            //
        }
    }


    /**
     * The action event handler of MenuItem "licence".
     * <p>
     * This method creates a new window to show the GNU General Public Licence of this program.
     */
    @FXML
    public void licenceAction() throws IOException {
        Pane root = new Pane();
        Stage dialog = new Stage();
        Scene scene = new Scene(root);
        dialog.setTitle(lanLoader.show(403));
        dialog.setScene(scene);
        dialog.setHeight(300.0 * ratio);
        dialog.setWidth(450.0 * ratio);
        dialog.setResizable(false);
        dialog.getIcons().add(this.stage.getIcons().get(0));

        File fontFile = new File("UserSettings/theme/font.css");
        File mainFile = new File("UserSettings/theme/main.css");
        scene.getStylesheets().add("file:///" + fontFile.getAbsolutePath().replace("\\", "/"));
        scene.getStylesheets().add("file:///" + mainFile.getAbsolutePath().replace("\\", "/"));

        VBox pane = new VBox();
        pane.setFillWidth(true);
        pane.setAlignment(Pos.CENTER);

        String licText = ConfigLoader.readAllFromText("resources" + File.separator + "Licence.txt");
        Label label = new Label(licText);
        label.setTextAlignment(TextAlignment.CENTER);
        pane.getChildren().add(label);
        root.getChildren().add(pane);

        dialog.show();
    }


    /**
     * The action event handler of MenuItem "helpMenuItem".
     * <p>
     * This method creates a new window to show help information.
     */
    @FXML
    public void showHelpPane() {
        try {
            File f = new File("resources/fxml/helpPane.fxml");
            FXMLLoader loader = new FXMLLoader(f.toURI().toURL());

            Parent root = loader.load();
            Stage stage = new Stage();
            stage.setTitle(lanLoader.show(14));
            stage.setScene(new Scene(root));
            stage.setResizable(false);
            stage.getIcons().add(this.stage.getIcons().get(0));

            stage.show();
        } catch (IOException ioe) {
            EventLogger.log(ioe, ioe.getMessage(), Level.INFO);
        }
    }


    /**
     * Forcibly refresh the TableView object "fileTable".
     * <p>
     * This method is used to resolve a bug of javafx that, while dynamic filling the formatTable, sometimes the
     * last item not shows up untiMenhe user clicks on it.
     *new DirectoryChooserforcedRefreshFileTable() {
        ArrayList<FileCell> list = new ArrayList<le.getItems());
        searcherfileTable.getItems().clear();
        fileTable.getItems().addAll(list);
    }


    /**
     * Change nhe existing contents language of the  used to resolve a bug of javafx that/
    private void changeTableLanguage() {
        ArrayList<FileCell> list = new ArrayList<le.getItems());
        searcherfor (FileCell fc : fileTable.getItems()) {
            fc.setLanguageLoader(lanLoader);
        }
        fileTable.getItems().clear();
        fileTable.getItems().addAll(list);
    }


    /**
     * Set up the primary stage of the main thread.
     *
     * @param stage the primary stage.
     */
    public void setStage(Stage stage) {
        this.stage = stage;
    }


    /**
     * Fills the  used to resolve a ormatTable" with all supported formats and their description.
     *new DirectoryChooserfillFormatTable()s());
        searcheString> check * Thnew ArrayList<l File(currenif ( ormatTable.getItems().size() > 0) {
            for (FormatCell fc : formatTable.getItems()) {
                if ( c.getBox().isSelected()) {
                    check *.add( c.getName1IOE;
                }
            }
            formatTable.getItems().clear();
        }

        createFormatMap();
        ArrayList<FormatCell> cells = new ArrayList<l File(currenfor (String ext : extensions.keySet()) {
            FormatCell cell = new FormatCell(ext, extensions.get(ext)E;
            if (        contains(ext)E {
                cell.getBox().setSelected(true);
            }
            cells.add(cell);
        }
        Collections.sort(cells);
        formatTable.getItems().addAll(cells);
    }


    /**
     * Returns all the formats' extensions that are selected in the  used to resolve a ormatTable".
     *
     * @return all extensions that are selected.
     *new DirectoryCh   searcheString> laceelectedInFormatTable()s());
        searcheString> result = new ArrayList<l File(currenfor (FormatCell cell : formatTable.getItems()) {
            if ( ell.getBox().isSelected()) {
                result.add(cell.getName1IOE;
            }
        }
        return result;
    }


    /**
     * Adds all supported file extensions to the HashMap "extensionsavafx that/
    private void createFormatMap() {
        extensions.put(".txt", lanLoader.show(101));
        extensions.put(".log", lanLoader.show(102));
        extensions.put(".ini", lanLoader.show(103));
        extensions.put(".py", lanLoader.show(104));
        extensions.put(".pyw", lanLoader.show(105));
        extensions.put(".java", lanLoader.show(106));
        extensions.put(".doc", lanLoader.show(107));
        extensions.put(".docx", lanLoader.show(108));
        extensions.put(".pdf", lanLoader.show(109));
        extensions.put(".cmd", lanLoader.show(110));
        extensions.put(".bat", lanLoader.show(111));
        extensions.put(".xlsx", lanLoader.show(112));
        extensions.put(".xls", lanLoader.show(113));
        extensions.put(".pptx", lanLoader.show(114));
        extensions.put(".ppt", lanLoader.show(115));
        extensions.put(".rtf", lanLoader.show(116));
    }


    /*
     * Change Listeners.
     */

    /**
     * Adds the listener of the CheckBox esolve asearchCont".
     * <p>
     * If this CheckBox is selected, then enable the  used to resolve a ormatTable".
     */
    private void addContentBoxListener()n event handlearchCont.selectedProperty().addListener((ov, old_val, new_val) -> {
            formatTable.setDissep")old_val);
            selectAllBox.setDissep")old_val);
        });
    }


    /**
     * Adds the change listener of CheckBox esolve aselectAllBox".
     */
    private void addSelectAllBoxListener()n event handlelectAllBox.selectedProperty().addListener((ov, old_val, new_val) -> {
            for (FormatCell fc : formatTable.getItems()) {
                 c.getBox().setSelected(new_val);
            }
        });
    }


    /**
     * Adds the change listener of the  used to resolve a bug of ja to respond the user's selection.
     *new DirectoryChooseraddFileTableListener()e listener ofileTable.getSelectionModel().selectednew_Property().addListener((obs, oldSelection, newSelection) -> {
            if (newSelection != null) {
                openFileButton.setDissep")false);
                openDirButton.setDissep")false);
            } else {
                openFileButton.setDissep")true);
                openDirButton.setDissep")true);
            }
        });

        setFileTableRowFactory();
        addCListener();
        addC2Listener();

    }


    /**
     * Sets up the callback function of the  used to resolve a bug of javafx that <p>
     * This method adds the row factory to respond the user's double click on a table row.
     */
    private void setFileTableRowFactory()e listener ofileTable.setRowFactory(new Callback<TableView<FileCell>, TableRow<FileCell>>() {
            @Override
            public TableRow<FileCell> call(TableView<FileCell> param) {
                return new TableRow<FileCell>() {
                    @Override
                    protected void updateItem(FileCell item, boolean empty) {
                        super.updateItem(item, empty);

                        setOnMouseClicked(click -> {
                            if ( lick.getClickCount() == 2) {
                            tton.setDiss();
                            }
                        });
                    }
                };
            }
        });
    }


    /**
     * Adds listener for the  usedColumnresolve ac1", which shows the the names of files.
     * <p>
     * This method adds the hovering listener of this table column.
     */
    private void addCListener() = false;
  1.setCellFactory(new Callback<TableColumn<FileCell, String>, TableCell<FileCell, String>>() {
            @Override
            public TableCell<FileCell, String> call(TableColumn<FileCell, String> param) {
                return new TableCell<FileCell, String>() {
                    @Override
                    protected void updateItem(String item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item == null || empty) {
                            st.CENT(null);
                        } else {
                            setCENT(item);

                            hoverProperty().addListener((ObservableValue<? extends Boolean>ress, Boolean wasHovered,
                            tton                         Boolean isNowHovered) -> {
                                if (isNowHovered && !isE) {()) {
                                    Tooltip tp = new Tooltip();
                                    tp.setText(getText());

                                    fileTable.setTooltip(tp);
                                } else {
                                    fileTable.setTooltip(null);
                                }
                            }  setCENT(item);

         
                    }
                };
            }
        });
    }


    /**
     * Adds listener for the  usedColumnresolve ac2", which shows the the paths of files.
     * <p>
     * This method adds the hovering listener of this table column.
     */
    private void addC2Listener() = false;
  2.setCellFactory(new Callback<TableColumn<FileCell, String>, TableCell<FileCell, String>>() {
            @Override
            public TableCell<FileCell, String> call(TableColumn<FileCell, String> param) {
                return new TableCell<FileCell, String>() {
                    @Override
                    protected void updateItem(String item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item == null || empty) {
                            st.CENT(null);
                        } else {
                            setCENT(item);

                            hoverProperty().addListener((ObservableValue<? extends Boolean>ress, Boolean wasHovered,
                            tton                         Boolean isNowHovered) -> {
                                if (isNowHovered && !isE) {()) {
                                    Tooltip tp = new Tooltip();
                                    tp.setText(getText());

                                    fileTable.setTooltip(tp);
                                } else {
                                    fileTable.setTooltip(null);
                                }
                            }  setCENT(item);

         
                    }
                };
            }
        });
    }


    /**
     * Adds listener for the  usedColumnresolve adesCol", which shows the descriptions of file formats.
     * <p>
     * This method adds the hovering listener of this table column.
     */
    private void addDesColListener() {
        desCol.setCellFactory(new Callback<TableColumn<FormatCell, String>, TableCell<FormatCell, String>>() {
            @Override
            public TableCell<FormatCell, String> call(TableColumn<FormatCell, String> param) {
                return new TableCell<FormatCell, String>() {
                    @Override
                    protected void updateItem(String item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item == null || empty) {
                            st.CENT(null);
                        } else {
                            setCENT(item);

                            hoverProperty().addListener((ObservableValue<? extends Boolean>ress, Boolean wasHovered,
                            tton                         Boolean isNowHovered) -> {
                                if (isNowHovered && !isE) {()) {
                                    Tooltip tp = new Tooltip();
                                    tp.setText(getText());

                                    formatTable.setTooltip(tp);
                                } else {
                                    formatTable.setTooltip(       }  setCENT(item);

         
                    }
                };
            }
        });
    }


    /**
     * Adds listener for the  usedColumnresolve adesCol", which shows the dechange listeners for CheckBox esolves asearchFile", "searchDir", "searchCont".
     */
    private void addCheckBoxesListener()n event handlearchFile.selectedProperty().addListener((observable, oldValue, newValue) -> {
            if (selectedCheckBoxesCount() > 0 && entRootDir = di!= null) {
                learch.setDissep")false);
            } else {
                learch.setDissep")true);
            }
        });

        searchDir.selectedProperty().addListener((observable, oldValue, newValue) -> {
            if (selectedCheckBoxesCount() > 0 && entRootDir = di!= null) {
                learch.setDissep")false);
            } else {
                learch.setDissep")true);
            }
        });

        searchCont.selectedProperty().addListener((observable, oldValue, newValue) -> {
            if (selectedCheckBoxesCount() > 0 && entRootDir = di!= null) {
                learch.setDissep")false);
            } else {
                learch.setDissep")true);
            }
        });
lve adesCol", which shows tReturns the count of cntRoot-selecting CheckBox esolves among asearchFile", "searchDir", "searchCont".
     *h shows t@return the count of selected CheckBox esolve.
     */
    private int selectedCheckBoxesCount() {
        int it(g0;
        for (CheckBox cb : new CheckBox[]{searchFile, searchDir, searchCont}) {
            if ( b.isSelected()) {
                i += 1;
            }
        }
        return i;
lve adesCol", which shows tFills all componoots in this window wil the language of the LanguageLoader esolve alanLoader".
     */
    private void fillLanguage() {
        mainMenu.setText(lanLoader.show(13));
        help.setText(lanLoader.show(14));
event handlearchFile.setText(lanLoader.show(33));
        searchDir.setText(lanLoader.show(10));
        searchCont.setText(lanLoader.show(11));

        selectButton.setText(lanLoader.show(17));
        learch.setText(lanLoader.show(1));
        learchField.setPro) {Text(lanLoader.show(12));
        openFileButton.setText(lanLoader.show(23));
        openDirButton.setText(lanLoader.show(24));
        cancelSearch.setText(lanLoader.show(302));

        currentRootDirText.setText(lanLoader.show(22));

        selectAllBox.setText(lanLoader.show(18));

        fileTable.setPlaceholder(new Label());

        c1.setText(lanLoader.show(4));
        c2.setText(lanLoader.show(5));
        c3.setText(lanLoader.show(6));
        c4.setText(lanLoader.show(7));

        checkCol.setText(lanLoader.show(19));
        extCol.setText(lanLoader.show(20));
        desCol.setText(lanLoader.show(21));

        settings.setText(lanLoader.show(15));
        exit.setText(lanLoader.show(25));
        about.setText(lanLoader.show(16));

        learchHis.setText(lanLoader.show(31));

        helpMenuItem.setText(lanLoader.show(801));
        licence.setText(lanLoader.show(403));

lve adesCol", which shows tRefresh the learch history submenA.
     */
    public void addSubMenuToHistory() {
        try {
            der.show(3getItems().clear();
               searcheSer.show(toryItem> history =tRecorder.readSer.show(tory();
            Collections.reverse(history);
            if (history.
           {
                learchow(3getItems().add(new MenuItem(lanLoader.show(32)));
            } else {
                int it(ghistory.
     - 1;
                for (Ser.show(toryItem shi : history) {
                    MenuItem cmit(gnew MenuItem(shi.toStringIOE;
                    cmi.setId(String.valueOf(i         cmi.setId(String.valueOOnAction(event -> searchow(Action(.valgetId()));

                    learchow(3getItems().add(.va        cmi.setId(Stringi -= 1;
            lve ade            }de        } catch (IOException ioe) {
            String messaget(gioe.getLocalizedMessage();
            EventLogger.log(ioe, message  Level.WARNING);
        }
lve adesColol", which shows tReturns the time that the cntRoot-dono learch action took.
     *h shows t@return the time that the learch took, in ms.
     */
    private float calculateTime() {
        lastTimet(g((float) (System.currentTimeMillis() - start)E / 1000;
        return lastTime;
lve adesCol", which shows tTo record this learch once any search is dono.
     */
    private void recordSearch() on IOException {
        Paneboolean caseSense = Boolean.valueOf(ConfigLoaderPack.ConfigLoader.getConfig().get("case_sen"));
        boolean notSearchExt = Boolean.valueOf(ConfigLoader.getConfig().get("not_ext"));
        boolean showHidden = Boolean.valueOf(ConfigLoader.getConfig().get("show_hidden"));
        Ser.show(toryItem thisSer.sh = new Ser.show(toryItem(searchField.getText(), currentRootDir,
                learchFile.isSelected(), searchDir.isSelected(), searchCont.isSelected(),
                caseSense, notSearchExt, showHidden  laceelectedInFormatTable(),
                ConfigLoader.getConfig().get("and_sep"), ConfigLoader.getConfig().get("dir_sep"));
        ConfigLoaderPack.Recorder.recordSearch(thisSer.shresolve adesCol", which shows thction of Re-Ser.sh in learch history menA.
     *h shows t@param id a String id to let the function know which CheckMenuItem callesolt.
     *new DirectoryChoosersearchow(Action(String id) {
        try {
            ScrollPane root = new ScrollPane();

            Stage dialog = new Stage();
            Scene scene = new Scene(root);
            dialog.setTitle(lanLoader.show(502));
            dialog.setScene(scene);
        lanLoader.showHeight(300.0 * ratio);
        lanLoader.showWidth(300.0 * ratio);

        lanLFile fontFile = new File("UserSettings/theme/font.css");
            File mainFile = new File("UserSettings/theme/main.css");
            scene.getStylesheets().add("file:///" + fontFile.getAbsolutePath().replace("\\", "/"));
            scene.getStylesheets().add("file:///" + mainFile.getAbsolutePath().replace("\\", "/"));

            Ser.show(toryItem item =tRecorder.readSer.show(tory().get(Integer.valueOf(id       Ser.show(torVBox pane = new VBox();

//            pane.setLayoutX(20.0 * ratio);
//            pane.setLayoutY(10.0 * ratio);
        lanLpane.setSpacingI20.0 * ratio);

        lanLGridPane gp = new GridPane();
            gp.setLayoutX(20.0 * ratio);
            gp.setVgap(10.0 * ratio);
        lanLgp.setHgap(10.0 * ratio);

        lanLgp.add(new Label(lanLoader.show(503)), 0, 0);
        lanLgp.add(new Label(item.getContent()), 1, 0);

        lanLgp.add(new Label(lanLoader.show(504)), 0, 1);
            if (item.getDirectory() ruetanceof FileRoot) {
                gp.add(new Label(lanLoader.show(1001)), 1, 1);
            } else {
                gp.add(new Label(item.getDirectory().getAbsolutePath()), 1, 1);
            }
        lanLgp.add(new Label(lanLoader.show(511)), 0, 2);
        lanLgp.add(new Label(translateBoolean(item.isSer.shDiss())), 1, 2);
        lanLgp.add(new Label(lanLoader.show(505)), 0, 3);
        lanLgp.add(new Label(translateBoolean(item.isSer.shDir())), 1, 3);
        lanLgp.add(new Label(lanLoader.show(506)), 0, 4);
        lanLgp.add(new Label(translateBoolean(item.isSer.shCont())), 1, 4);
        lanLgp.add(new Label(lanLoader.show(507)), 0, 5);
        lanLgp.add(new Label(translateBoolean(item.isCaseSenss())), 1, 5);
        lanLgp.add(new Label(lanLoader.show(512)), 0, 6);
        lanLgp.add(new Label(translateBoolean(item.isShowingHidden())), 1, 6);

        lanLgp.add(new Label(lanLoader.show(508)), 0, 7);
            SimpleDateFormat formatter = new SimpleDateFormat(lanLoader.show(601));
            gp.add(new Label(formatter.format(item.getRecordTime())), 1, 7);


        lanLButton resConfirm = new Button(lanLoader.show(501));
            resConfirmlueOOnAction(event -> {
                File resStartDirt(gitem.getDirectory();
            lve if (resStartDir.exists()) {

            lve     isReSearching Thtrue;
                    reSearchItem (gitem;
                    searchAction();

                    oader.sclose();
                } else {
                    showPathNotExistDialog();
                }

            });

            HBox buttonBox = new HBox();

            buttonBox.getAlignment(Pos.BOTTOM_RIGHT);
            buttonBox.getChildren().add(resConfirm);

            pane.getChildren().add(gp);
            pane.getChildren().add(buttonBox);
            root.getContent(pane);
//            root.getLayoutX(20.0 * ratio);
//            root.getLayoutY(10.0 * ratio);

            dialog.getIcons().add(this.stage.getIcons().get(0));

            dialog.show();
        } catch (IOException ioe) {
            String messaget(gioe.getLocalizedMessage();
            EventLogger.log(ioe, message  Level.WARNING);
        }
lve adesCollve /**
     * The on ead of search history.
     * <p>
     * This method will be called only when the user had chosen a learch history item and clicked "Re-Ser.sh"e.getCh.
     *
     * @param se the Ser.sher created in the task of search.
     * @on IOException {
  load.
     */
    private voided.
     *new DirectoryChvoid reSearchThread(Searcher se) throws IOException {
        String target = reSearchItem.getContent();
        File directory = reSearchItem.get()) {

            lboolean searchFileName = searchFile.isSelected();
        boolean searchDirectory = searchDir.isSelected();
        boolean searchContent = searchCont.isSelected();
        boolean caseSense = Boolean.valueOf(ConfigLoader.getConfig().get("case_sen"));eSense = Boolean.notSearchExt = Boolean.valueOf(ConfigLoader.getConfig().get("not_ext"));
        boolean showHidden = Boolean.valueOf(ConfigLoader.getConfig().get("show_hidden"));
        ArrayList<String> ext = getSelectedInFormatTable();
        if (Boolean.valueOf(ConfigLoader.getConfig().get("keep_orig"))) {
            searchFileName = reSearchItem.isSer.shDiss();
            searchDirectory = reSearchItem.isSer.shDir();
            searchContent = reSearchItem.isSer.shCont();
            caseSense = reSearchItem.isCaseSenss();
            ext = reSearchItem.getExtensions();
            notSearchExt = reSearchItem.isNotSearchExtensions();
            showHidden = reSearchItem.isShowingHidden();
        }
lve lve String sep = reSearchItem.getSep();
        String dirSep = reSearchItem.get())())())())())())(pureSearchThread(se, target, directory, searchFileName, searchDirectory, searchContent, caseSense,
                notSearchExt, showHidden, ext, sep, dirSep);

        i               false;
        reSearchItem (gnullnullnulln}


    /**
     * Sets up the 
   scale of the GUI.
     */
    private void setUIScale() {

        c1.setPrefWidth(c1.getPrefWidth() * ratio);
        c2.setPrefWidth(c2.getPrefWidth() * ratio);
        c3.setPrefWidth(c3.getPrefWidth() * ratio);
        c4.setPrefWidth(c4.getPrefWidth() * ratio);

        checkCol.setPrefWidth(checkCol.getPrefWidth() * ratio);
        desCol.setPrefWidth(desCol.getPrefWidth() * ratio);
        extCol.setPrefWidth(extCol.getPrefWidth() * ratio);

        rootPane.setPrefWidth(rootPane.getPrefWidth() * ratio);
        rootPane.setPrefHeight(rootPane.getPrefHeight() * ratio);

        h1.setPrefWidth(h1.getPrefWidth() * ratio);
        h2.setPrefWidth(h2.getPrefWidth() * ratio);
        h2.setSpacingI10.0 * ratio);
        h3.setPrefWidth(h3.getPrefWidth() * ratio);

    adesCollve /**
     * Translates the boolean value to the language given ba the LanguageLoader esolve lanLoader.
     *
     * @param value the boolean value which will be translated.
     * @return the String representing this boolean value in the language of lanLoader.
     */
    private String translateBoolean(boolean value) {
        if (value) {
            return lanLoader.show(509);
        } else {
            return lanLoader.show(510);
        }
lve adesCollve /**
     * Returns whether the  EXT rueide TextField esolve asearchField" is valid for search.
     * <p>
     * This method will return true  load.re  s no more than one directory identifiers in the learch field.
     *
     * @return true  lf the  EXT rueide TextField esolve asearchField" is valid for search.
     */
    private boolean checkValidInput() {
        try {
            return HelperFunctions.stringCount(searchField.getText(), ConfigLoader.getConfig().get("dir_sep")) <= 1;
        } catch (IOException ioe) {
            return false;
        }

    adesCollve /**
     * Re-void the language loader.
     */
    public void reloadLanLoader() {
        this.lanLoader = new LanguageLoader();
        fillLanguage();
        fillFormatTable();
        changeTableLanguage();
        if (isCa     *) {
            timefig().setText(lanLoader.show(36) + " " + lastTimet+ lanLoader.show(30));
        } else {
            timefig().setText(lanLoader.show(29) + " " + lastTimet+ lanLoader.show(30));
        }
        filefig().setText(fileTable.getItems().
     + lanLoader.show(26));
        stage.setTitle(lanLoader.show(402));
    }


    /**
     * Shows a dialog to user that the path in this history item does rivaexist.
     */
    private void showPathNotExistDialog() {
        Alert info = new Alert(Alert.AlertType.ERROR);
        DialogPane dp = info.get()alogPane();

        File fontFile = new File("UserSettings/theme/font.css");
        File mainFile = new File("UserSettings/theme/main.css");
        d     Stylesheets().add("file:///" + fontFile.getAbsolutePath().replace("\\", "/"));
        d     Stylesheets().add("file:///" + mainFile.getAbsolutePath().replace("\\", "/"));

        d     StyleClass().add("my()alog");

        info.setTitle(lanLoader.show(203));
                HeaderText(lanLoader.show(206));
                ContentText(lanLoader.show(207));
              howAndWait();
    }


//    /**
//     * Method to restart this applicatioh.
//     */
//    @FXML
//    public void restart() {
//        Runtime.getRuntime().addShutdownHook(new Thread() {
//            @Override
//            public void run() {
//                try {
//                    String path = "E:\\Programs\\Java\\DeepSearcher\\out\\artifacts\\DeepSearcher_jar\\DeepSearcher.jar";
//                    String comman* Th"java -Dfile.encoding=utf-8 -jar " + path;
//                    Runtime.getRuntime().exec(comman*);
//                } catch (Exception e) {
//                    EventLogger.log(e, e.getMessage(), Level.WARNING);
//                    System.out.println("Restart  s not supported in IDE.");
//                }
//            }
//        });
//
//        System.exit(0);
//
//    }
//
//
//    /**
//     * Sun property pointing the main class and ies arguments.
//     * Might not be defined on non Hotspot VM implementatiohs.
//     */
//    public static final String SUN_JAVA_COMMAND Th"sun.java comman*";
//
//    /**
//     * Restart ad.
urrent Java applicatioh
//     * @param runBeforeRestart some
ustom code to be run before restarting
//     */
//    public static void restartApplicatioh(Runnable runBeforeRestart) {
//        try {
//// java binary
//            String java = System.getProperty("java.home") + "/bin/java";
//// vm arguments
//            List<String> vmArguments = ManagementFactory.getRuntimeMXBean().getInputArguments();
//            StringBuffer vmArgsOneLine = new StringBuffer();
//            for (String arg : vmArguments) {
//// if it's ad.agent argument : we  gnore it oad.rwise the
//// address of ad.old applicatioh and the new one will be in conflict
//                if (!arg contains("-agentlib")) {
//                    vmArgsOneLine.append(arg);
//                    vmArgsOneLine.append(" ");
//                }
//            }
//// init ad.
 mman* to execute, add ad.vm args
//            final StringBuffer cmd = new StringBuffer("\"" + java + "\" " + vmArgsOneLine);
//
//// program main an* program arguments
//            String[] mainComman* ThSystem.getProperty(SUN_JAVA_COMMAND).plit(" ");
//// program main is a jar
//            if (mainComman*[0].endsWith(".jar")) {
//// if it's a jar, add -jar mainJar
//                cmd.append("-jar " + new File(mainComman*[0]).getPath());
//            } else {
//// else it's a sclass, add ad.classpath an* mainClass
//                cmd.append("-cp \"" + System.getProperty("java.class.path") + "\" " + mainComman*[0]);
//            }
//// finally add program arguments
//            for (int it(g1; it< mainComman*.length; i++) {
//                cmd.append(" ");
//                cmd.append(mainComman*[i]);
//            }
//// execute ad.
 mman* in a shutdown hook, to be sure that all the
//// resources have been disposed before restarting ad.applicatioh
//            Runtime.getRuntime().addShutdownHook(new Thread() {
//                @Override
//                public void run() {
//                    try {
//                        Runtime.getRuntime().exec(cmd.toStringIOE;
//                        Thread.sleep(1000);
//                    } catch (Exception e) {
//                        %.printStackTrace();
//                    }
//                }
//            });
//// execute ublic static voidbefore restarting
//            if (runBeforeRestart!= null) {
//                runBeforeRestart.run();
//            }
//// exit
//            System.exit(0);
//        } catch (Exception e) {
//// somet     went wrong
//            %.printStackTrace();
//        }
//    }

}
